### Πρώτη φάση εργασία στα Λειτουργικά Συστήματα

Το πρόγραμμα αποτελεί μια απλή υλοποίηση κελύφους με τη δυνατότητα:

1) Να εμφανίζει prompt

2) Να αναλύει τα ορίσματα με χρήση της εντολής **strtok**

3) Να εντοπίζει εκτελέσιμα στο PATH (χάρη στο ***find_in_path(char *cmd)**)

4) Να χρησιμοποιεί fork και execve για την εκτέλεση αυτών

5) Να αναφέρει τους κώδικες εξόδου (status)

6) Να εκτελεί προγράμματα όπως ls, cat, echo, και να τερματίζει με EOF ή την εντολή exit

7) Υλοποιήστε την ανακατεύθυνση εξόδου με τον τελεστή >. Το shell σας πρέπει να μπορεί να εκτελεί εντολές όπως ls -l > output.txt

8) Επεκτείνετε την υλοποίηση για να υποστηρίζει και >>.Για παράδειγμα, ls -l >> output.txt.

9) Υλοποιήστε έναν απλό αγωγό (|) μεταξύ δύο εντολών χρησιμοποιώντας τη συνάρτηση pipe(). Για παράδειγμα, ls -l | grep ".txt"

10) Επεκτείνετε την υλοποίηση για να υποστηρίζει αλυσίδες από πολλαπλούς αγωγούς. Παράδειγμα ls -l | grep ".txt" | wc -l

11) Υλοποιήστε συνδυασμό των παραπάνω. Για παράδειγμα,cat file.txt | grep mystring >> grepresults.txt

12) Εκτέλεση στο Παρασκήνιο με `&`: Τροποποιήστε τον parser εντολών του shell ώστε να ανιχνεύει το σύμβολο `&` στο τέλος, και όταν υπάρχει, παραλείψτε την κλήση `tcsetpgrp` και μην περιμένετε (block) για το παιδί—αντίθετα εκτυπώστε τον αριθμό εργασίας και το PID, και επιστρέψτε αμέσως στην προτροπή ενώ η διεργασία τρέχει στο δικό της process group.

13) Χειρισμός Σημάτων για Ctrl-C και Ctrl-Z: Εγκαταστήστε handlers χρησιμοποιώντας `sigaction` ώστε το shell να αγνοεί τα `SIGINT` και `SIGTSTP`, και στη συνέχεια στη διεργασία-παιδί (μετά το `fork`, πριν το `exec`) επαναφέρετε αυτά τα σήματα σε `SIG_DFL` ώστε μόνο το process group της εργασίας προσκηνίου να λαμβάνει και να ανταποκρίνεται στα σήματα διακοπής και αναστολής από το τερματικό.

14) Ενσωματωμένες Εντολές `fg` και `bg`: Υλοποιήστε την `fg` αναζητώντας την εργασία από το όρισμα `%N`, στέλνοντας `SIGCONT` στο process group της με `kill(-pgid, SIGCONT)`, καλώντας `tcsetpgrp` για να της δώσετε έλεγχο του τερματικού, και περιμένοντας να τελειώσει ή να ανασταλεί· υλοποιήστε την `bg` με τον ίδιο τρόπο αλλά παραλείψτε την κλήση `tcsetpgrp` και μην περιμένετε, επιτρέποντας στην εργασία να συνεχίσει να τρέχει στο παρασκήνιο.

Το πρόγραμμα είναι εξ' ολοκλήρου γραμμένο σε C.

Για να τρέξει, **απαιτείται τερματικό σε Linux (Ubuntu,Unix,Fedora)** λόγω των βιβλιοθηκών **<sys/types.h>, <sys/wait.h>**. Δημιουρήθηκαν 4 αρχεια:

- **mytinyshell.h**: το οποίο περιέχει όλες τις βιβλιοθήκες και τις μεταβλητές που χρειάστηκαν για τον κώδικα.
- **myfuctions.c**: περιέχει τις συναρτήσεις που χρειάστηκαν για το πρόγραμμα (char *find_in_path(char *cmd), int parse_command(char *segment, char *args[], char **infile, char **outfile, int *append_out, char **errfile)).
- **tinyshell.c**: περιέχει την βασική συνάστηση που εκτελεί το shell.
- **makefile**: περιέχει εντολές για την εκτέλεση με την εντολή make.


## Οδηγίες Εγκατάστασης:
1) Βάλτε όλα τα αρχεία μεσά στον ίδιο φάκελο

2) Ανοίξτε το τερματικό σε Linux.

3) Κάντε compile του tinyshell με χρήση της εντολής

- Αν το αρχείο είναι αποθηκευμένο στα **Windows**:

**gcc /mnt/c/Users/(διαδρομή)/tinyshell.c myfunction.c -o ~/tinyshell**

όπου (διαδρομή) η διαδρομή του αρχείου

- Αν το αρχείο είναι αποθηκευμένο στα **Linux:**

Μετακινηθείτε μέσα στο φάκελο που βάλατε όλα τα αρχεία με την εντολη cd.

**gcc ~/tinyshell.c myfunction.c -o ~/tinyshell**

- Εναλλακτικά μεταφέρτε το αρχείο από τα Windows στα Linux με την εντολή

**cp /mnt/c/Users/yourusername/path/{tinyshell.c,myfunction.c,mytinyshell.h,makefile} ~/**  και συνεχίστε κανονικά

μετακινηθείτε μέσα στο φάκελο που βάλατε όλα τα αρχεία με την εντολή cd και εκτελέστε.

**gcc ~/tinyshell.c myfunction.c -o ~/tinyshell**

Απαραίτητη προυπόθεση να έχει προηγηθεί η εγκατάσταση του gcc.

Αν δεν έχετε εγκαταστήσει το gcc πρέπει:

α)Να τρέξετε το τερματικό του Linux (Ubuntu,Unix) ως διαχειριστής (run as administrator)

β)Να βάλετε τον κωδικό σας

γ)Να τρέξετε **sudo apt install gcc**

δ)Να τρέξετε **gcc --version** για να δείτε αν η εγκατάσταση ολοκληρώθηκε σωστά

ε)Να κλείσετε το τερματικό και να το ξαναανοίξετε 

5) Αφού κάνετε compile το αρχείο c, είστε έτοιμοι να το τρέξετε

Πληκτρολογήστε **cd <YourUsername>** για να βρεθείτε στην διεύθυνση του προγράμματος (αν για κάποιο λόγο δεν βρίσκεστε εκεί). Προαιρετικά γράψτε ls για να βεβαιωθείτε ότι το tinyshell βρίσκεται στη λίστα αρχείων.

6) Εκτελέστε το πρόγραμμα με **./tinyshell**

Θα εμφανιστεί ένα prompt 

tinyshell>

7) Το πρόγραμμα εκτελείται! Δοκιμάστε ελεύθερα. (ls, echo, mkdir, pwd, touch, cat)


## Εναλακτικός τρόπος εκτέλεσεις
Δημιουργήθηκε ένα αρχείο **makefile** το οποίο διευκολύνει την έκτελεση του προγράμματος. Απαραίτητη προηπόθεση είναι να είστε μέσα στον φάκελο που έχετε αποθηκεύσει τα αρχεία. Υποστηρίζει τις παρακάτω εντολές

1) make all
Το πρόγραμμα κάνει compile τα εξής: 
- gcc -c tinyshell_2.c
- gcc -c myfuctions.c
- gcc tinyshell.o myfuctions.o -o tinyshell_2.
και παράγει τα αρχεία που χρειαζεται για να παράζει το εκτελέσιμο.

2) make tinyshell
- gcc -c tinyshell_2.c
- gcc -c myfuctions.c
- gcc tinyshell_2.o myfuctions.o -o tinyshell_2


3) make tinyshell_2.o myfynctions.o
- gcc -c tinyshell_2.c
- gcc -c myfuctions.c

4) make run
Τρέχει το πρόγραμμα.

5) make clean
- Σβήνει τα αρχεία από που τελειώνουν σε .ο.

6) make purge
- Σβήνει τα αρχεία από που τελειώνουν σε .ο και το εκτελέσιμο.

Για να εκτελεστεί το πρόγραμμα πρέπει να εκτελεστούν οι εντολές:
- make all
- make run

Προφανώς μπορείτε να πειραματιστείτε με τις εντολές.

### Ενδικτικές εντολές για έλεγχο.
- ls
- echo hello
- cat file.txt (δημιουργίστε πρώτα το file.txt γράφοντας απλά κάτι στο εσωτερικό του)
- pwd
- ls -la /tmp
- abc (για λανθασμένη εντολη ή οποια άλλη θέλετε)
- Έλεγχος κωδικών εξόδων: bin/true και /bin/false
- exit
- Ctrl + D
- ls -l > output.txt
- ls -l >> output.txt
- ls -l | grep ".txt"
- ls -l | grep ".txt" | wc -l
- cat file.txt | grep mystring >> grepresults.txt
- ```
    sleep 100 &
    ls -la ```
- ``` 
    sleep 100
    ^C
    sleep 100
    ^Z ```
- ```
    sleep 100
    ^Z
    bg %1
    fg %1
    ^C ```
